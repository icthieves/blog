= Pwnable.kr - UAF Writeup 
//See https://hubpress.gitbooks.io/hubpress-knowledgebase content/ for information about the parameters.
:hp-image: /images/covers/space.jpg
:published_at: 2017-05-24
:hp-tags: use-after-free, pwnable.kr, ctf, writeups
:hp-alt-title: Use-After-Free fun in glibc!

#### Challenge Description: 
> Mommy, what is Use After Free bug?
> ssh uaf@pwnable.kr -p2222 (pw:guest)

#### First Impressions: 

image::/images/blog/uaf/uaf1.png["The Challenge Directory"]

Here we find the usual readable source code, executable binary, and unreadable flag.

Looking at the source code we see that it defines a simple virtual class (Human) and its two subclasses (Man/Woman).

image::/images/blog/uaf/main.png["The uaf/cpp main() function"]

The switch block is what's interesting to us at the moment.
We are prompted with three options:

> [1] Call the *introduce()* method of both the Man and Woman objects.

Notice that both the Man* and Woman* from the *new* keyword are cast to *Human**. Clearly, this objects are in the same class heirarchy, and Human is a common superclass. Further still, notice that we call introduce(), _A function with the same prototype, using two upcasted objects._ Either we are calling the *introduce()* method of the Human class, or there's some as yet unseen polymorphism mechanism that de-obfuscates our function call. Running the code, you can see that *Man->introduce()* and *Woman->introduce()* _do not produce the same output for identical calls_, therefore, *they must be virtual functions.*

(This is, of course, extremely obvious because the classes are both defined in this same readable file, but you can still figure out a lot without the class definitions.)

> [3] Delete (and deconstruct) both the Man and Woman objects.

Huh, so we can delete the objects, then use their newly invalidated pointers to call a function.

image::/images/blog/uaf/segfault.png["Segfault by accessing a dangling pointer."]

So, it's clearly possible to _use_ our pointers _after they are free'd_, but what weirdness can we cause with this?
Well, this is where you would start googling "use after free", and eventually you might find link:https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/[this extremely good article on glibc's malloc() internals], and link:https://sourceware.org/glibc/wiki/MallocInternals[this very handy reference for glibc malloc()].


After reading the articles linked above, you might start to see how a Use-After-Free vulnerability can be exploited. Because it is extremely expensive for a process to allocate memory through syscalls like *sbrk()* and *mmap()*, glibc *malloc()* avoids this as much as possible by maintaining sorted "bins" of unallocated memory.

When *malloc()* is called, It first uses a best-fit algorithm and searches through it's binlists for the first free chunk of adequate size. If one is found, It resizes the chunk (if necessary) and returns a pointer to the start of the chunk's data section.
That means if we *free()* and object, then _allocate something of the same size_, there is a 99% chance that we will get a pointer to *exact same chunk that we just free'd.*








