= Pwnable.kr - UAF Writeup 
//See https://hubpress.gitbooks.io/hubpress-knowledgebase content/ for information about the parameters.
:hp-image: /images/covers/space.jpg
:published_at: 2017-05-24
:hp-tags: use-after-free, pwnable.kr, ctf, writeups
:hp-alt-title: Use-After-Free fun in glibc!

#### Challenge Description: 
> Mommy, what is Use After Free bug?
> ssh uaf@pwnable.kr -p2222 (pw:guest)

#### First Impressions: 

image::/images/blog/uaf/uaf1.png["The Challenge Directory"]

Here we find the usual readable source code, executable binary, and unreadable flag.

Looking at the source code we see that it defines a simple virtual class (Human) and its two subclasses (Man/Woman).

image::/images/blog/uaf/main.png["The uaf/cpp main() function"]

The switch block is what's interesting to us at the moment.
We are prompted with three options:

> [1] Call the *introduce()* method of both the Man and Woman objects.

Notice that both the Man* and Woman* from the *new* keyword are cast to *Human**. Clearly, this objects are in the same class heirarchy, and Human is a common superclass. Further still, notice that we call introduce(), _A function with the same prototype, using two upcasted objects._ Either we are calling the *introduce()* method of the Human class, or there's some as yet unseen polymorphism mechanism that de-obfuscates our function call. Running the code, you can see that *Man->introduce()* and *Woman->introduce()* _do not produce the same output for identical calls_, therefore, *they must be virtual functions.*

(This is, of course, extremely obvious because the classes are both defined in this same readable file, but you can still figure out a lot without the class definitions.)



This is a good time to take a look at the *Human* class and its subclasses.

image::/images/blog/uaf/human.png["The Human class and it's subclasses."]
We can immediately see the goal of this challenge: find a way to call *give_shell()* in the *Human* class. 
Notice that the class contains two _virtual functions_, only one of which is overwritten by the subclasses.


Now let's look at the last option in the switch block.

> [3] Delete (and deconstruct) both the Man and Woman objects.

Huh, so we can delete the objects, then use their newly invalidated pointers to call a function.

image::/images/blog/uaf/segfault.png["Segfault by accessing a dangling pointer."]

So, it's clearly possible to _use_ our pointers _after they are free'd_, but what weirdness can we cause with this?
Well, this is where you would start googling "use after free", and eventually you might find link:https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/[this extremely good article on glibc's malloc() internals], and link:https://sourceware.org/glibc/wiki/MallocInternals[this very handy reference for glibc malloc()].


After reading the articles linked above, you might start to see how a Use-After-Free vulnerability can be exploited. Because it is extremely expensive for a process to allocate memory through syscalls like *sbrk()* and *mmap()*, glibc *malloc()* avoids this as much as possible by maintaining sorted "bins" of unallocated memory.

When *malloc()* is called, It first uses a best-fit algorithm and searches through it's binlists for the first free chunk of adequate size. If one is found, It resizes the chunk (if necessary) and returns a pointer to the start of the chunk's data section.
That means if we *free()* and object, then _allocate something of the same size_, there is a 99% chance that we will get a pointer to *exact same chunk that we just free'd.*

But how can this be exploited?
Well, We know we can call a function from  the *Man* and *Woman* classes after they are free'd and we know that we can potentially write arbitrary data to the chunk their dangling pointers refer to.
The key insight to exploiting this, is abusing C++'s _Vtables_

image::/images/blog/uaf/vtables.png["Vtable memory block"]

link:http://www.fuzzysecurity.com/tutorials/expDev/11.html[Image Source]

C++ polymorphism requires some compiler trickery to work properly. For example, if i have an instance of *Man* and i cast it to *Human*, what happens when i call *introduce()*?
We would expect *Man->introduce()* to be invoked, and indeed this is what happens. But how did we know (given a *Human* pointer, which was the "real" function to call?

This is where _Vtables_ come in, and while the specifics vary between compilers (the standard specifies the language, not the implementation) we'll cover the general idea.
Every class instance in a C++ program has a _Vtable_, which is included *as the first member of the object*. This table is an ordered list of function pointers that point to the methods of this particular class in the class heirarchy. If a class inherits a method, then its Vtable entry for that method will be the same pointer as its parent (to prevent repeating an identical method).


Because an object's type may not be known until runtime, the vtables for related classes *must be in the same order*.

image::/images/blog/uaf/call-introduce.png["Disassembly of the switch block"]

Here is a radare2 control flow graph of the *uaf* binary. notice the block at *0x13ab*. We know from analyzing the cmp instructions to get here that this must be the block that calls *Man->introduce()* and *Women->introduce()*.
And, indeed, we can see two *call* instructions, with nearly identical arguments.

Let's go over this segment byte by byte:
> mov rax, qword [local_18h]
This instruction loads a value at address *local_18h* to rax.
> mov rax, qword [rax]
This is telling. We're _dereferencing_ the value we just stored. clearly, *local_18h* must be a pointer to something.
> add rax,8 
now we add an offset of 8 bytes.
> mov rax, qword [rax]
> call rax
And we _dereference the register again and call it!_

This tells us some important information: We take a pointer to a pointer, add an offset, and call it.

Thinking back to the description of Vtables above, We can start to piece together what is happening here.
1. *local_18h* is the start of the Vtable for this object
2. *The second entry* of the vtable (+0x8) is the method we are calling.
3. looking to the second *call instruction*, we can see that it uses a *the very next address* as it's vtable pointer, and *the exact same 0x8 offset*.

The sharp-eyed reader may notice that i said _the first member of a class instance is a Vtable pointer_, but the second Vtable pointer is immediately after the first. What gives?

image::/images/blog/uaf/class-members.png["Class Definitions"]

Looking back at the source, we can indeed see that the *Man* and *Woman* subclasses inherit other members (a string and an int). Where are they, then?

Well, Nowhere in the program do we edit these values; Once the class is constructed, they are fixed. The compiler likely placed these variables in a different segment, along with the program's global variables.
As such, the only actual "member" of these classes are their Vtable pointers, everything else is stored globally.

Now, thinking back to the offsets used for the Vtable pointer: We know that the Vtables of related classes *must have the same ordering*, so *local_18h+0x8* and *local_20h+0x8* must be different implementations of the same function (in this case, *introduce()*). But if *introduce()* is the second method in both these classes, What is the first? What is *local_18h*?

One last time, let's go back to the source code, this time looking at the *Human* class.

We can see that there is indeed a method defined before *introduce()*, which is *give_shell()*. Now all the pieces snap into place. Since *Man* and *Woman* are derived classes of *Human*, they *inherit the give_shell() function!*
Since this is very first method defined in the class heirarchy, this must be the first method in the vtable, *local_18h* and *local_20h* (remember, inherited methods will point to the same function.)

*All we need to do to call give_shell() instead of introduce(), is subtract 0x8 from the vtable entry for introduce(), and allocate it to the free'd chunk.* Then, when we call *Man->introduce()*, it'll call the method before it in the vtable (0x8-0x8=0, the first method of the class).

Great! we've solved the logic of the challenge _without even needing to run the program._
To get our final address, we just need to debug the program, and break on the *call* to *introduce()*. Taking the address of this method, subtracting 0x8, and writing it to the front of a 24-Byte chunk with option *2*, should effectively confuse the program into calling *give_shell()* instead of *introduce()*.

The rest is just tying everything together.
(Pwnable.kr is down at the time of writing, So expect a bow to be put on this article in a day or two.)









